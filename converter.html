<html>
<head>
<title>CFVisualise</title>
<script type="text/javascript">var gzipEnabled = false;</script>
<script type="text/javascript" src="gzipcheck.js.jgz"></script>
<link rel="stylesheet" type="text/css" href="visualise.css" />
<script type="text/javascript">
var currentURL = "";
var getParams = "";

// CHECK FOR GZIP
(function() {
	var fileref=document.createElement("link"); fileref.setAttribute("rel", "stylesheet"); fileref.setAttribute("type", "text/css");
	var scriptElementJQuery = document.createElement('script'); scriptElementJQuery.type = 'text/javascript'; scriptElementJQuery.async = false;
	var scriptElementXML = document.createElement('script'); scriptElementXML.type = 'text/javascript'; scriptElementXML.async = false;
	if (gzipEnabled) {
		scriptElementJQuery.src = 'jquery.min.js.jgz';
		scriptElementXML.src = 'xml2json.js.jgz';
		//fileref.setAttribute("href", "visualise.css.cgz");
	} else {
		scriptElementJQuery.src = 'jquery.min.js';
		scriptElementXML.src = 'xml2json.js';
		//fileref.setAttribute("href", "visualise.css");
	}
	var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(scriptElementJQuery, s);
	var s1 = document.getElementsByTagName('script')[0]; s1.parentNode.insertBefore(scriptElementXML, s1);
	//document.getElementsByTagName("head")[0].appendChild(fileref);
})();

  var _gaq = _gaq || [];
  _gaq.push(['_setAccount', 'UA-23136765-3']);
  _gaq.push(['_trackPageview']);

  (function() {
  if (window.location.hostname != "localhost") {
    var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
    ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
    var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
	}
  })();
</script>
<script type="text/javascript">
var cnt = 0;

function removeObj(obj, val) { 
	for (var i in obj) {
		//console.log("Key: "+i+" "+typeof(obj[i]));
		if (i == val) {
			console.log("Deleting: "+typeof(obj[i]));
			delete obj[i];
		}
		else {
			if (obj[i] instanceof Object) {
				removeObj(obj[i], val);
			}
		}
	}
	return;
}

function parseXMLDom (text) {
if (window.DOMParser)
  {
  parser=new DOMParser();
  xmlDoc=parser.parseFromString(text,"text/xml");
  }
else // Internet Explorer
  {
  xmlDoc=new ActiveXObject("Microsoft.XMLDOM");
  xmlDoc.async=false;
  xmlDoc.loadXML(text);
  }
return xmlDoc;
}

function displayResult(xml, xsl, divid)
{
// code for IE
if (window.ActiveXObject)
  {
  ex=xml.transformNode(xsl);
  document.getElementById(divid).innerHTML=ex;
  }
// code for Mozilla, Firefox, Opera, etc.
else if (document.implementation && document.implementation.createDocument)
  {
  xsltProcessor=new XSLTProcessor();
  xsltProcessor.importStylesheet(xsl);
  resultDocument = xsltProcessor.transformToFragment(xml,document);
  document.getElementById(divid).appendChild(resultDocument);
  }
}

function loadXMLDoc(dname)
{
if (window.ActiveXObject)
  {
  xhttp=new ActiveXObject("Msxml2.XMLHTTP.3.0");
  }
else
  {
  xhttp=new XMLHttpRequest();
  }
xhttp.open("GET",dname,false);
xhttp.send("");
return xhttp.responseXML;
}

function initPage() {
var x2js = new X2JS({
	escapeMode : true,
	skipEmptyTextNodesForObj : true
});
var source_json = document.getElementById("template").value;
var process_json = source_json;
// Adjust Function References to different namespaces
process_json = process_json.replace(/fn::/g, 'fn:');
process_json = process_json.replace(/Fn::/g, 'fn:');
process_json = process_json.replace(/AWS::CloudFormation::/g, 'fn:cloudformation-');
process_json = process_json.replace(/aws::cloudformation::/g, 'fn:cloudformation-');
process_json = process_json.replace(/\"32\"\ :/g, '"a32" :');
process_json = process_json.replace(/\"64\"\ :/g, '"a64" :');
process_json = process_json.replace(/\"64Cluster\"\ :/g, '"a64Cluster" :');
process_json = process_json.replace(/\"64GPU\"\ :/g, '"a64GPU" :');
process_json = process_json.replace(/\"64HVM\"\ :/g, '"a64HVM" :');
// Load JSON
var json_object = jQuery.parseJSON( process_json );
// Remove Elements
removeObj(json_object, "Metadata");
removeObj(json_object, "UserData");
// Get Updated JSON Object
var xmlDocStr = "<?xml version=\"1.0\"?>\n<fn:functions xmlns:fn=\"http://aws.amazon.com/CFvisuliser/functions\">\n<cloudformation>"+x2js.json2xml_str(json_object)+"\n</cloudformation>\n</fn:functions>";
// Adjust XML
xmlDocStr = xmlDocStr.replace(/<0>/g, '<n0>');
xmlDocStr = xmlDocStr.replace(/<\/0>/g, '<\/n0>');
xmlDocStr = xmlDocStr.replace(/<1>/g, '<n1>');
xmlDocStr = xmlDocStr.replace(/<\/1>/g, '<\/n1>');
xmlDocStr = xmlDocStr.replace(/<2>/g, '<n1>');
xmlDocStr = xmlDocStr.replace(/<\/2>/g, '<\/n1>');
xmlDocStr = xmlDocStr.replace(/<3>/g, '<n1>');
xmlDocStr = xmlDocStr.replace(/<\/3>/g, '<\/n1>');
xmlDocStr = xmlDocStr.replace(/<4>/g, '<n1>');
xmlDocStr = xmlDocStr.replace(/<\/4>/g, '<\/n1>');
// Add in a variable to indicate to the XSL about using gzip'd links
// TODO
// Display result
xmlDoc = parseXMLDom(xmlDocStr);
document.getElementById("output").value = xmlDocStr;

// Display image
xsl = loadXMLDoc("visualise.xsl");
displayResult(xmlDoc, xsl, "diagram");
console.log("initPage completed");
return;
}

function regen() {
document.getElementById("output").value = "";
document.getElementById("diagram").innerHTML = "";
if (document.getElementById("template").value != "") {
	initPage();
}
else {
	document.getElementById("diagram").innerHTML = "No Data Found";
}
var diagram_div = document.getElementById("diagram");
var diagram_button = document.getElementById("diagram_button");
var template_div = document.getElementById("template-screen");
var template_button = document.getElementById("template_button");
var debug_div = document.getElementById("debug-screen");
var debug_button = document.getElementById("debug_button");
diagram_div.style.display = "block";
diagram_button.className = "menu-item-selected";
template_div.style.display = "none";
template_button.className = "menu-item";
debug_div.style.display = "none";
debug_button.className = "menu-item";
}

function menuSelect(self) {
	var menutoselect = self.lastChild.textContent;
	var diagram_div = document.getElementById("diagram");
	var diagram_button = document.getElementById("diagram_button");
	var template_div = document.getElementById("template-screen");
	var template_button = document.getElementById("template_button");
	var debug_div = document.getElementById("debug-screen");
	var debug_button = document.getElementById("debug_button");
	//alert (self.lastChild.textContent);
	switch(menutoselect) {
		case "View Diagram":	diagram_div.style.display = "block";
								diagram_button.className = "menu-item-selected";
								template_div.style.display = "none";
								template_button.className = "menu-item";
								debug_div.style.display = "none";
								debug_button.className = "menu-item";
								break;
		case "Template":		diagram_div.style.display = "none";
								diagram_button.className = "menu-item";
								template_div.style.display = "block";
								template_button.className = "menu-item-selected";
								debug_div.style.display = "none";
								debug_button.className = "menu-item";
								break;
		case "Debug":			diagram_div.style.display = "none";
								diagram_button.className = "menu-item";
								template_div.style.display = "none";
								template_button.className = "menu-item";
								debug_div.style.display = "block";
								debug_button.className = "menu-item-selected";
								break;
		default:				break;
	}
}

function getTemplateAction() {
	var urlToget = document.getElementById("templateURL").value;
	if ((urlToget == "") || (urlToget == "Enter Address")) {
		console.log ("No template found");
		return;
	}
	if (urlToget.contains("https://")) {
		alert ("https is not supported, please use http");
		return;
	}
	//redirect
	var sentToURL = currentURL+"?url="+encodeURIComponent(urlToget);
	window.location=sentToURL;
}

function getTemplateByURL(urlToget) {
	urlToget = urlToget.replace ("http://", "http://www.corsproxy.com/");
	console.log ("getting template: "+urlToget);
	var xhr = createCORSRequest('GET', urlToget);
	if (!xhr) {
		Alert('CORS not supported by the browser');
		return;
	}
	document.getElementById("template").value = xhr.responseText;
}

function createCORSRequest(method, url) {
  var xhr = new XMLHttpRequest();
  if ("withCredentials" in xhr) {

    // Check if the XMLHttpRequest object has a "withCredentials" property.
    // "withCredentials" only exists on XMLHTTPRequest2 objects.
    xhr.open(method, url, false);

  } else if (typeof XDomainRequest != "undefined") {

    // Otherwise, check if XDomainRequest.
    // XDomainRequest only exists in IE, and is IE's way of making CORS requests.
    xhr = new XDomainRequest();
    xhr.open(method, url, false);

  } else {

    // Otherwise, CORS is not supported by the browser.
    xhr = null;

  }
  xhr.send();
  return xhr;
}

function loadUpCall() {
	var loc = window.location;
	currentURL = loc.protocol + '//' + loc.host + loc.pathname;
	var prmstr = loc.search.substr(1);
	var prmarr = prmstr.split ("&");
	var params = {};

	if (loc.search != "") {
		for ( var i = 0; i < prmarr.length; i++) {
			var tmparr = prmarr[i].split("=");
			params[tmparr[0]] = tmparr[1];
		}
		if (params.url != "") {
			document.getElementById("templateURL").value = decodeURIComponent(params.url);
			getTemplateByURL(decodeURIComponent(params.url));
			regen();
		}
	}
	else {
		initPage();
	}
}
</script>
</head>

<body onload="javascript:loadUpCall();">
<div class="topMenu">
	<table width="100%">
	<tr>
	<td class="topMenuText">CFVisualise</td>
	<td><div id="diagram_button" class="menu-item-selected" onclick="javascript:menuSelect(this);">View Diagram</div></td>
	<td><div id="template_button" class="menu-item" onclick="javascript:menuSelect(this);">Template</div></td>
	<td><div id="debug_button" class="menu-item" onclick="javascript:menuSelect(this);">Debug</div></td>
	<td class="topMenuText">&nbsp;URL:</td>
	<td width="100%"><input class="topURL" size='' type="text" id="templateURL" value="Enter Address" onmouseover="javascript:if (this.value == 'Enter Address') { this.value=''; }" onmouseout="javascript:if (this.value == '') { this.value='Enter Address'; }"/></td>
	<td><div id="get_button" class="menu-item-small" onclick="getTemplateAction();">GET</div></td>
	</tr>
	</table>
</div><br/>
<div id="diagram" class="diagram">

</div>
<div id="template-screen" class="template-screen">
<input type="submit" value="Regenerate from Text" name="regen" onclick="javascript:regen();"/><br/>
<h2>JSON CloudFormation Template</h2>
<textarea id="template">
{
  "AWSTemplateFormatVersion" : "2010-09-09",

  "Description" : "AWS CloudFormation Sample Template multi-tier-web-app-in-vpc.template: Sample template showing how to create a multi-tier web application in a VPC with multiple subnets. The first subnet is public and contains and internet facing load balancer, a NAT device for internet access from the private subnet and a bastion host to allow SSH access to the hosts in the private subnet. The second subnet is private and contains a Frontend fleet of EC2 instances, an internal load balancer and a Backend fleet of EC2 instances. **WARNING** This template creates Elastic Load Balancers and Amazon EC2 instances. You will be billed for the AWS resources used if you create a stack from this template.",

  "Parameters" : {

    "KeyName" : {
      "Description" : "Name of an existing EC2 KeyPair to enable SSH access to the instances",
      "Type" : "String",
      "MinLength": "1",
      "MaxLength": "64",
      "AllowedPattern" : "[-_ a-zA-Z0-9]*",
      "ConstraintDescription" : "can contain only alphanumeric characters, spaces, dashes and underscores."
    },

    "SSHLocation" : {
      "Description" : "Lockdown SSH access to the bastion host (default can be accessed from anywhere)",
      "Type" : "String",
      "MinLength": "9",
      "MaxLength": "18",
      "Default" : "0.0.0.0/0",
      "AllowedPattern" : "(\\d{1,3})\\.(\\d{1,3})\\.(\\d{1,3})\\.(\\d{1,3})/(\\d{1,2})",
      "ConstraintDescription" : "must be a valid CIDR range of the form x.x.x.x/x."
    },

    "FrontendInstanceType" : {
      "Description" : "Frontend Server EC2 instance type",
      "Type" : "String",
      "Default" : "m1.small",
      "AllowedValues" : [ "t1.micro","m1.small","m1.medium","m1.large","m1.xlarge","m2.xlarge","m2.2xlarge","m2.4xlarge","m3.xlarge","m3.2xlarge","c1.medium","c1.xlarge","cc1.4xlarge","cc2.8xlarge","cg1.4xlarge"],
      "ConstraintDescription" : "must be a valid EC2 instance type."
    },

    "FrontendSize" : {
      "Description" : "Number of EC2 instances to launch for the Frontend server",
      "Type" : "Number",
      "Default" : "1"
    },

    "BackendInstanceType" : {
      "Description" : "Backend Server EC2 instance type",
      "Type" : "String",
      "Default" : "m1.small",
      "AllowedValues" : [ "t1.micro","m1.small","m1.medium","m1.large","m1.xlarge","m2.xlarge","m2.2xlarge","m2.4xlarge","m3.xlarge","m3.2xlarge","c1.medium","c1.xlarge","cc1.4xlarge","cc2.8xlarge","cg1.4xlarge"],
      "ConstraintDescription" : "must be a valid EC2 instance type."
    },

    "BackendSize" : {
      "Description" : "Number of EC2 instances to launch for the backend server",
      "Type" : "Number",
      "Default" : "1"
    },

    "BastionInstanceType" : {
      "Description" : "Bastion Host EC2 instance type",
      "Type" : "String",
      "Default" : "m1.small",
      "AllowedValues" : [ "t1.micro","m1.small","m1.medium","m1.large","m1.xlarge","m2.xlarge","m2.2xlarge","m2.4xlarge","m3.xlarge","m3.2xlarge","c1.medium","c1.xlarge","cc1.4xlarge","cc2.8xlarge","cg1.4xlarge"],
      "ConstraintDescription" : "must be a valid EC2 instance type."
    },

    "NATInstanceType" : {
      "Description" : "NET Device EC2 instance type",
      "Type" : "String",
      "Default" : "m1.small",
      "AllowedValues" : [ "t1.micro","m1.small","m1.medium","m1.large","m1.xlarge","m2.xlarge","m2.2xlarge","m2.4xlarge","m3.xlarge","m3.2xlarge","c1.medium","c1.xlarge","cc1.4xlarge","cc2.8xlarge","cg1.4xlarge"],
      "ConstraintDescription" : "must be a valid EC2 instance type."
    },

    "HostedZone" : {
      "Type" : "String",
      "Description" : "The DNS name of an existing Amazon Route 53 hosted zone"
    }
  },

  "Mappings" : {
    "AWSNATAMI" : {
      "us-east-1"      : { "AMI" : "ami-c6699baf" },
      "us-west-2"      : { "AMI" : "ami-52ff7262" },
      "us-west-1"      : { "AMI" : "ami-3bcc9e7e" },
      "eu-west-1"      : { "AMI" : "ami-0b5b6c7f" },
      "ap-southeast-1" : { "AMI" : "ami-02eb9350" },
      "ap-southeast-2" : { "AMI" : "ami-ab990e91" },
      "ap-northeast-1" : { "AMI" : "ami-14d86d15" },
      "sa-east-1"      : { "AMI" : "ami-0439e619" }
    },

    "AWSInstanceType2Arch" : {
      "t1.micro"    : { "Arch" : "64" },
      "m1.small"    : { "Arch" : "64" },
      "m1.medium"   : { "Arch" : "64" },
      "m1.large"    : { "Arch" : "64" },
      "m1.xlarge"   : { "Arch" : "64" },
      "m2.xlarge"   : { "Arch" : "64" },
      "m2.2xlarge"  : { "Arch" : "64" },
      "m2.4xlarge"  : { "Arch" : "64" },
      "m3.xlarge"   : { "Arch" : "64" },
      "m3.2xlarge"  : { "Arch" : "64" },
      "c1.medium"   : { "Arch" : "64" },
      "c1.xlarge"   : { "Arch" : "64" },
      "cc1.4xlarge" : { "Arch" : "64Cluster" },
      "cc2.8xlarge" : { "Arch" : "64Cluster" },
      "cg1.4xlarge" : { "Arch" : "64GPU" }
    },

    "AWSRegionArch2AMI" : {
      "us-east-1"      : { "32" : "ami-a0cd60c9", "64" : "ami-aecd60c7", "64Cluster" : "ami-a8cd60c1",      "64GPU" : "ami-eccf6285" },
      "us-west-2"      : { "32" : "ami-46da5576", "64" : "ami-48da5578", "64Cluster" : "NOT_YET_SUPPORTED", "64GPU" : "NOT_YET_SUPPORTED" },
      "us-west-1"      : { "32" : "ami-7d4c6938", "64" : "ami-734c6936", "64Cluster" : "NOT_YET_SUPPORTED", "64GPU" : "NOT_YET_SUPPORTED" },
      "eu-west-1"      : { "32" : "ami-61555115", "64" : "ami-6d555119", "64Cluster" : "ami-67555113",      "64GPU" : "NOT_YET_SUPPORTED" },
      "ap-southeast-1" : { "32" : "ami-220b4a70", "64" : "ami-3c0b4a6e", "64Cluster" : "NOT_YET_SUPPORTED", "64GPU" : "NOT_YET_SUPPORTED" },
      "ap-southeast-2" : { "32" : "ami-b3990e89", "64" : "ami-bd990e87", "64Cluster" : "NOT_YET_SUPPORTED", "64GPU" : "NOT_YET_SUPPORTED" },
      "ap-northeast-1" : { "32" : "ami-2a19aa2b", "64" : "ami-2819aa29", "64Cluster" : "NOT_YET_SUPPORTED", "64GPU" : "NOT_YET_SUPPORTED" },
      "sa-east-1"      : { "32" : "ami-f836e8e5", "64" : "ami-fe36e8e3", "64Cluster" : "NOT_YET_SUPPORTED", "64GPU" : "NOT_YET_SUPPORTED" }
    },

    "SubnetConfig" : {
      "VPC"     : { "CIDR" : "10.0.0.0/16" },
      "Public"  : { "CIDR" : "10.0.0.0/24" },
      "Private" : { "CIDR" : "10.0.1.0/24" }
    }
  },

  "Resources" : {


    "VPC" : {
      "Type" : "AWS::EC2::VPC",
      "Properties" : {
        "CidrBlock" : { "Fn::FindInMap" : [ "SubnetConfig", "VPC", "CIDR" ]},
        "Tags" : [
          { "Key" : "Application", "Value" : { "Ref" : "AWS::StackId" } },
          { "Key" : "Network", "Value" : "Public" }
        ]
      }
    },

    "PublicSubnet" : {
      "Type" : "AWS::EC2::Subnet",
      "Properties" : {
        "VpcId" : { "Ref" : "VPC" },
        "CidrBlock" : { "Fn::FindInMap" : [ "SubnetConfig", "Public", "CIDR" ]},
        "Tags" : [
          { "Key" : "Application", "Value" : { "Ref" : "AWS::StackId" } },
          { "Key" : "Network", "Value" : "Public" }
        ]
      }
    },

    "InternetGateway" : {
      "Type" : "AWS::EC2::InternetGateway",
      "Properties" : {
        "Tags" : [
          { "Key" : "Application", "Value" : { "Ref" : "AWS::StackId" } },
          { "Key" : "Network", "Value" : "Public" }
        ]
      }
    },

    "GatewayToInternet" : {
       "Type" : "AWS::EC2::VPCGatewayAttachment",
       "Properties" : {
         "VpcId" : { "Ref" : "VPC" },
         "InternetGatewayId" : { "Ref" : "InternetGateway" }
       }
    },

    "PublicRouteTable" : {
      "Type" : "AWS::EC2::RouteTable",
      "Properties" : {
        "VpcId" : { "Ref" : "VPC" },
        "Tags" : [
          { "Key" : "Application", "Value" : { "Ref" : "AWS::StackId" } },
          { "Key" : "Network", "Value" : "Public" }
        ]
      }
    },

    "PublicRoute" : {
      "Type" : "AWS::EC2::Route",
      "DependsOn" : "GatewayToInternet",
      "Properties" : {
        "RouteTableId" : { "Ref" : "PublicRouteTable" },
        "DestinationCidrBlock" : "0.0.0.0/0",
        "GatewayId" : { "Ref" : "InternetGateway" }
      }
    },

    "PublicSubnetRouteTableAssociation" : {
      "Type" : "AWS::EC2::SubnetRouteTableAssociation",
      "Properties" : {
        "SubnetId" : { "Ref" : "PublicSubnet" },
        "RouteTableId" : { "Ref" : "PublicRouteTable" }
      }
    },

    "PublicNetworkAcl" : {
      "Type" : "AWS::EC2::NetworkAcl",
      "Properties" : {
        "VpcId" : { "Ref" : "VPC" },
        "Tags" : [
          { "Key" : "Application", "Value" : { "Ref" : "AWS::StackId" } },
          { "Key" : "Network", "Value" : "Public" }
        ]
      }
    },

    "InboundHTTPPublicNetworkAclEntry" : {
      "Type" : "AWS::EC2::NetworkAclEntry",
      "Properties" : {
        "NetworkAclId" : { "Ref" : "PublicNetworkAcl" },
        "RuleNumber" : "100",
        "Protocol" : "6",
        "RuleAction" : "allow",
        "Egress" : "false",
        "CidrBlock" : "0.0.0.0/0",
        "PortRange" : { "From" : "80", "To" : "80" }
      }
    },

    "InboundHTTPSPublicNetworkAclEntry" : {
      "Type" : "AWS::EC2::NetworkAclEntry",
      "Properties" : {
        "NetworkAclId" : { "Ref" : "PublicNetworkAcl" },
        "RuleNumber" : "101",
        "Protocol" : "6",
        "RuleAction" : "allow",
        "Egress" : "false",
        "CidrBlock" : "0.0.0.0/0",
        "PortRange" : { "From" : "443", "To" : "443" }
      }
    },

    "InboundSSHPublicNetworkAclEntry" : {
      "Type" : "AWS::EC2::NetworkAclEntry",
      "Properties" : {
        "NetworkAclId" : { "Ref" : "PublicNetworkAcl" },
        "RuleNumber" : "102",
        "Protocol" : "6",
        "RuleAction" : "allow",
        "Egress" : "false",
        "CidrBlock" : { "Ref" : "SSHLocation" },
        "PortRange" : { "From" : "22", "To" : "22" }
      }
    },

    "InboundEmphemeralPublicNetworkAclEntry" : {
      "Type" : "AWS::EC2::NetworkAclEntry",
      "Properties" : {
        "NetworkAclId" : { "Ref" : "PublicNetworkAcl" },
        "RuleNumber" : "103",
        "Protocol" : "6",
        "RuleAction" : "allow",
        "Egress" : "false",
        "CidrBlock" : "0.0.0.0/0",
        "PortRange" : { "From" : "1024", "To" : "65535" }
      }
    },

    "OutboundPublicNetworkAclEntry" : {
      "Type" : "AWS::EC2::NetworkAclEntry",
      "Properties" : {
        "NetworkAclId" : { "Ref" : "PublicNetworkAcl" },
        "RuleNumber" : "100",
        "Protocol" : "6",
        "RuleAction" : "allow",
        "Egress" : "true",
        "CidrBlock" : "0.0.0.0/0",
        "PortRange" : { "From" : "0", "To" : "65535" }
      }
    },

    "PublicSubnetNetworkAclAssociation" : {
      "Type" : "AWS::EC2::SubnetNetworkAclAssociation",
      "Properties" : {
        "SubnetId" : { "Ref" : "PublicSubnet" },
        "NetworkAclId" : { "Ref" : "PublicNetworkAcl" }
      }
    },

    "PrivateSubnet" : {
      "Type" : "AWS::EC2::Subnet",
      "Properties" : {
        "VpcId" : { "Ref" : "VPC" },
        "CidrBlock" : { "Fn::FindInMap" : [ "SubnetConfig", "Private", "CIDR" ]},
        "Tags" : [
          { "Key" : "Application", "Value" : { "Ref" : "AWS::StackId" } },
          { "Key" : "Network", "Value" : "Private" }
        ]
      }
    },

    "PrivateRouteTable" : {
      "Type" : "AWS::EC2::RouteTable",
      "Properties" : {
        "VpcId" : { "Ref" : "VPC" },
        "Tags" : [
          { "Key" : "Application", "Value" : { "Ref" : "AWS::StackId" } },
          { "Key" : "Network", "Value" : "Private" }
        ]
      }
    },

    "PrivateSubnetRouteTableAssociation" : {
      "Type" : "AWS::EC2::SubnetRouteTableAssociation",
      "Properties" : {
        "SubnetId" : { "Ref" : "PrivateSubnet" },
        "RouteTableId" : { "Ref" : "PrivateRouteTable" }
      }
    },

    "PrivateRoute" : {
      "Type" : "AWS::EC2::Route",
      "Properties" : {
        "RouteTableId" : { "Ref" : "PrivateRouteTable" },
        "DestinationCidrBlock" : "0.0.0.0/0",
        "InstanceId" : { "Ref" : "NATDevice" }
      }
    },

    "PrivateNetworkAcl" : {
      "Type" : "AWS::EC2::NetworkAcl",
      "Properties" : {
        "VpcId" : { "Ref" : "VPC" },
        "Tags" : [
          { "Key" : "Application", "Value" : { "Ref" : "AWS::StackId" } },
          { "Key" : "Network", "Value" : "Private" }
        ]
      }
    },

    "InboundPrivateNetworkAclEntry" : {
      "Type" : "AWS::EC2::NetworkAclEntry",
      "Properties" : {
        "NetworkAclId" : { "Ref" : "PrivateNetworkAcl" },
        "RuleNumber" : "100",
        "Protocol" : "6",
        "RuleAction" : "allow",
        "Egress" : "false",
        "CidrBlock" : "0.0.0.0/0",
        "PortRange" : { "From" : "0", "To" : "65535" }
      }
    },

    "OutBoundPrivateNetworkAclEntry" : {
      "Type" : "AWS::EC2::NetworkAclEntry",
      "Properties" : {
        "NetworkAclId" : { "Ref" : "PrivateNetworkAcl" },
        "RuleNumber" : "100",
        "Protocol" : "6",
        "RuleAction" : "allow",
        "Egress" : "true",
        "CidrBlock" : "0.0.0.0/0",
        "PortRange" : { "From" : "0", "To" : "65535" }
      }
    },

    "PrivateSubnetNetworkAclAssociation" : {
      "Type" : "AWS::EC2::SubnetNetworkAclAssociation",
      "Properties" : {
        "SubnetId" : { "Ref" : "PrivateSubnet" },
        "NetworkAclId" : { "Ref" : "PrivateNetworkAcl" }
      }
    },

    "NATIPAddress" : {
      "Type" : "AWS::EC2::EIP",
      "DependsOn" : "GatewayToInternet",
      "Properties" : {
        "Domain" : "vpc",
        "InstanceId" : { "Ref" : "NATDevice" }
      }
    },

    "NATDevice" : {
      "Type" : "AWS::EC2::Instance",
      "Properties" : {
        "InstanceType" : { "Ref" : "NATInstanceType" },
        "KeyName" : { "Ref" : "KeyName" },
        "SubnetId" : { "Ref" : "PublicSubnet" },
        "SourceDestCheck" : "false",
        "ImageId" : { "Fn::FindInMap" : [ "AWSNATAMI", { "Ref" : "AWS::Region" }, "AMI" ]},
        "SecurityGroupIds" : [{ "Ref" : "NATSecurityGroup" }]
      }
    },

    "NATSecurityGroup" : {
      "Type" : "AWS::EC2::SecurityGroup",
      "Properties" : {
        "GroupDescription" : "Enable internal access to the NAT device",
        "VpcId" : { "Ref" : "VPC" },
        "SecurityGroupIngress" : [
           { "IpProtocol" : "tcp", "FromPort" : "80",  "ToPort" : "80",  "CidrIp" : "0.0.0.0/0"} ,
           { "IpProtocol" : "tcp", "FromPort" : "443", "ToPort" : "443", "CidrIp" : "0.0.0.0/0"} ,
           { "IpProtocol" : "tcp", "FromPort" : "22",  "ToPort" : "22",  "CidrIp" : { "Ref" : "SSHLocation" }} ],
        "SecurityGroupEgress" : [
           { "IpProtocol" : "tcp", "FromPort" : "80",  "ToPort" : "80",  "CidrIp" : "0.0.0.0/0"} ,
           { "IpProtocol" : "tcp", "FromPort" : "443", "ToPort" : "443", "CidrIp" : "0.0.0.0/0"} ]
      }
    },

    "BastionIPAddress" : {
      "Type" : "AWS::EC2::EIP",
      "DependsOn" : "GatewayToInternet",
      "Properties" : {
        "Domain" : "vpc",
        "InstanceId" : { "Ref" : "BastionHost" }
      }
    },

    "BastionHost" : {
      "Type" : "AWS::EC2::Instance",
      "Properties" : {
        "InstanceType" : { "Ref" : "BastionInstanceType" },
        "KeyName"  : { "Ref" : "KeyName" },
        "SubnetId" : { "Ref" : "PublicSubnet" },
        "ImageId"  : { "Fn::FindInMap" : [ "AWSRegionArch2AMI", { "Ref" : "AWS::Region" }, { "Fn::FindInMap" : [ "AWSInstanceType2Arch", { "Ref" : "BastionInstanceType" }, "Arch" ] } ] },
        "SecurityGroupIds" : [{ "Ref" : "BastionSecurityGroup" }]
      }
    },

    "BastionSecurityGroup" : {
      "Type" : "AWS::EC2::SecurityGroup",
      "Properties" : {
        "GroupDescription" : "Enable access to the Bastion host",
        "VpcId" : { "Ref" : "VPC" },
        "SecurityGroupIngress" : [ { "IpProtocol" : "tcp", "FromPort" : "22",  "ToPort" : "22",  "CidrIp" : { "Ref" : "SSHLocation" }} ],
        "SecurityGroupEgress"  : [ { "IpProtocol" : "tcp", "FromPort" : "22",  "ToPort" : "22",  "CidrIp" : { "Fn::FindInMap" : [ "SubnetConfig", "Private", "CIDR" ]}}]
      }
    },

    "PublicElasticLoadBalancer" : {
      "Type" : "AWS::ElasticLoadBalancing::LoadBalancer",
      "Properties" : {
        "SecurityGroups" : [ { "Ref" : "PublicLoadBalancerSecurityGroup" } ],
        "Subnets" : [ { "Ref" : "PublicSubnet" } ],
        "Listeners" : [ { "LoadBalancerPort" : "80", "InstancePort" : "80", "Protocol" : "HTTP" } ],
        "HealthCheck" : {
          "Target" : "HTTP:80/",
          "HealthyThreshold" : "3",
          "UnhealthyThreshold" : "5",
          "Interval" : "90",
          "Timeout" : "60"
        }
      }
    },

    "PublicLoadBalancerSecurityGroup" : {
      "Type" : "AWS::EC2::SecurityGroup",
      "Properties" : {
        "GroupDescription" : "Public ELB Security Group with HTTP access on port 80 from the internet",
        "VpcId" : { "Ref" : "VPC" },
        "SecurityGroupIngress" : [ { "IpProtocol" : "tcp", "FromPort" : "80", "ToPort" : "80", "CidrIp" : "0.0.0.0/0"} ],
        "SecurityGroupEgress" : [ { "IpProtocol" : "tcp", "FromPort" : "80", "ToPort" : "80", "CidrIp" : "0.0.0.0/0"} ]
      }
    },

    "FrontendFleet" : {
      "Type" : "AWS::AutoScaling::AutoScalingGroup",
      "Properties" : {
        "AvailabilityZones" : [{ "Fn::GetAtt" : [ "PrivateSubnet", "AvailabilityZone" ] }],
        "VPCZoneIdentifier" : [{ "Ref" : "PrivateSubnet" }],
        "LaunchConfigurationName" : { "Ref" : "FrontendServerLaunchConfig"  },
        "MinSize" : "1",
        "MaxSize" : "10",
        "DesiredCapacity" : { "Ref" : "FrontendSize" },
        "LoadBalancerNames" : [ { "Ref" : "PublicElasticLoadBalancer" } ],
        "Tags" : [ { "Key" : "Network", "Value" : "Public", "PropagateAtLaunch" : "true" } ]
      }
    },

    "FrontendServerLaunchConfig"  : {
      "Type" : "AWS::AutoScaling::LaunchConfiguration",
      "Metadata" : {
        "Comment1" : "Configure the FrontendServer to forward /backend requests to the backend servers",

        "AWS::CloudFormation::Init" : {
          "config" : {
            "packages" : {
              "yum" : {
                "httpd"        : []
              }
            },

            "files" : {
              "/var/www/html/index.html" : {
                "content" : { "Fn::Join" : ["\n", [
                  "<img src=\"https://s3.amazonaws.com/cloudformation-examples/cloudformation_graphic.png\" alt=\"AWS CloudFormation Logo\"/>",
                  "<h1>Congratulations, you have successfully launched the multi-tier AWS CloudFormation sample.</h1>",
                  "<p>This is a multi-tier web application launched in an Amazon Virtual Private Cloud (Amazon VPC) with multiple subnets. The first subnet is public and contains and internet facing load balancer, a NAT device for internet access from the private subnet and a bastion host to allow SSH access to the hosts in the private subnet. The second subnet is private and contains a Frontend fleet of EC2 instances, an internal load balancer and a Backend fleet of EC2 instances.",
                  "<p>To serve a web page from the backend service, click <a href=\"/backend\">here</a>.</p>"
                ]]},
                "mode"    : "000644",
                "owner"   : "root",
                "group"   : "root"
              },

              "/etc/httpd/conf.d/maptobackend.conf" : {
                "content" : { "Fn::Join" : ["", [
                   "ProxyPass /backend http://", { "Fn::GetAtt" : [ "PrivateElasticLoadBalancer", "DNSName" ]}, "\n",
                   "ProxyPassReverse /backend http://", { "Fn::GetAtt" : [ "PrivateElasticLoadBalancer", "DNSName" ]}, "\n"
                ]]},
                "mode"    : "000644",
                "owner"   : "root",
                "group"   : "root"
              }
            },

            "services" : {
              "sysvinit" : {
                "httpd" : {
                  "enabled"       : "true",
                  "ensureRunning" : "true",
                  "files"         : [ "/etc/httpd/conf.d/maptobackend.conf", "/var/www/html/index.html" ]
                }
              }
            }
          }
        }
      },
      "Properties" : {
        "ImageId"        : { "Fn::FindInMap" : [ "AWSRegionArch2AMI", { "Ref" : "AWS::Region" }, { "Fn::FindInMap" : [ "AWSInstanceType2Arch", { "Ref" : "FrontendInstanceType" }, "Arch" ] } ] },
        "SecurityGroups" : [ { "Ref" : "FrontendSecurityGroup" } ],
        "InstanceType"   : { "Ref" : "FrontendInstanceType" },
        "KeyName"        : { "Ref" : "KeyName" },
        "UserData"       : { "Fn::Base64" : { "Fn::Join" : ["", [
          "#!/bin/bash -v\n",
          "yum update -y aws-cfn-bootstrap\n",

          "# Install Apache and configure as a reverse Frontend\n",
          "/opt/aws/bin/cfn-init --stack ", { "Ref" : "AWS::StackId" }, " --resource FrontendServerLaunchConfig ",
          "    --region ", { "Ref" : "AWS::Region" }, "\n",

          "# Signal completion\n",
          "/opt/aws/bin/cfn-signal -e $? -r \"Frontend setup done\" '", { "Ref" : "FrontendWaitHandle" }, "'\n"
        ]]}}
      }
    },

    "FrontendSecurityGroup" : {
      "Type" : "AWS::EC2::SecurityGroup",
      "Properties" : {
        "GroupDescription" : "Allow access from load balancer and bastion as well as outbound HTTP and HTTPS traffic",
        "VpcId" : { "Ref" : "VPC" },
        "SecurityGroupIngress" : [
          { "IpProtocol" : "tcp", "FromPort" : "80", "ToPort" : "80", "SourceSecurityGroupId" : { "Ref" : "PublicLoadBalancerSecurityGroup" } } ,
          { "IpProtocol" : "tcp", "FromPort" : "22", "ToPort" : "22", "SourceSecurityGroupId" : { "Ref" : "BastionSecurityGroup" } } ],
        "SecurityGroupEgress" : [
           { "IpProtocol" : "tcp", "FromPort" : "80",  "ToPort" : "80",  "CidrIp" : "0.0.0.0/0" } ,
           { "IpProtocol" : "tcp", "FromPort" : "443", "ToPort" : "443", "CidrIp" : "0.0.0.0/0" } ]
      }
    },

    "FrontendWaitHandle" : {
      "Type" : "AWS::CloudFormation::WaitConditionHandle"
    },

    "FrontendWaitCondition" : {
      "Type" : "AWS::CloudFormation::WaitCondition",
      "DependsOn" : "FrontendFleet",
      "Properties" : {
        "Handle"  : { "Ref" : "FrontendWaitHandle" },
        "Timeout" : "300",
        "Count"   : { "Ref" : "FrontendSize" }
      }
    },


    "PrivateElasticLoadBalancer" : {
      "Type" : "AWS::ElasticLoadBalancing::LoadBalancer",
      "Properties" : {
        "SecurityGroups" : [ { "Ref" : "PrivateLoadBalancerSecurityGroup" } ],
        "Subnets" : [ { "Ref" : "PrivateSubnet" } ],
        "Listeners" : [ { "LoadBalancerPort" : "80", "InstancePort" : "80", "Protocol" : "HTTP" } ],
        "Scheme" : "internal",
        "HealthCheck" : {
          "Target" : "HTTP:80/",
          "HealthyThreshold" : "3",
          "UnhealthyThreshold" : "5",
          "Interval" : "90",
          "Timeout" : "60"
        }
      }
    },

    "PrivateLoadBalancerSecurityGroup" : {
      "Type" : "AWS::EC2::SecurityGroup",
      "Properties" : {
        "GroupDescription" : "Private ELB Security Group with HTTP access on port 80 from the Frontend Fleet only",
        "VpcId" : { "Ref" : "VPC" },
        "SecurityGroupIngress" : [ { "IpProtocol" : "tcp", "FromPort" : "80", "ToPort" : "80", "SourceSecurityGroupId" : { "Ref" : "FrontendSecurityGroup" } } ],
        "SecurityGroupEgress" : [ { "IpProtocol" : "tcp", "FromPort" : "80", "ToPort" : "80", "CidrIp" : "0.0.0.0/0" } ]
      }
    },

    "BackendFleet" : {
      "Type" : "AWS::AutoScaling::AutoScalingGroup",
      "Properties" : {
        "AvailabilityZones" : [{ "Fn::GetAtt" : [ "PrivateSubnet", "AvailabilityZone" ] }],
        "VPCZoneIdentifier" : [{ "Ref" : "PrivateSubnet" }],
        "LaunchConfigurationName" : { "Ref" : "BackendLaunchConfig"  },
        "MinSize" : "1",
        "MaxSize" : "10",
        "DesiredCapacity" : { "Ref" : "BackendSize" },
        "LoadBalancerNames" : [ { "Ref" : "PrivateElasticLoadBalancer" } ],
        "Tags" : [ { "Key" : "Network", "Value" : "Private", "PropagateAtLaunch" : "true" } ]
      }
    },

    "BackendLaunchConfig"  : {
      "Type" : "AWS::AutoScaling::LaunchConfiguration",
      "Metadata" : {
        "Comment1" : "Configure the Backend server to respond to requests",

        "AWS::CloudFormation::Init" : {
          "config" : {
            "packages" : {
              "yum" : {
                "httpd"        : []
              }
            },

            "files" : {
              "/var/www/html/index.html" : {
                "content" : { "Fn::Join" : ["\n", [
                   "<img src=\"https://s3.amazonaws.com/cloudformation-examples/cloudformation_graphic.png\" alt=\"AWS CloudFormation Logo\"/>",
                   "<h1>Congratulations, this request was served from the backend fleet</h1>"
                ]]},
                "mode"    : "000644",
                "owner"   : "root",
                "group"   : "root"
              }
            },

            "services" : {
              "sysvinit" : {
                "httpd" : {
                  "enabled"       : "true",
                  "ensureRunning" : "true",
                  "files"         : [ "/var/www/html/index.html" ]
                }
              }
            }
          }
        }
      },
      "Properties" : {
        "ImageId"        : { "Fn::FindInMap" : [ "AWSRegionArch2AMI", { "Ref" : "AWS::Region" }, { "Fn::FindInMap" : [ "AWSInstanceType2Arch", { "Ref" : "BackendInstanceType" }, "Arch" ] } ] },
        "SecurityGroups" : [ { "Ref" : "BackendSecurityGroup" } ],
        "InstanceType"   : { "Ref" : "BackendInstanceType" },
        "KeyName"        : { "Ref" : "KeyName" },
        "UserData"       : { "Fn::Base64" : { "Fn::Join" : ["", [
          "#!/bin/bash -v\n",
          "yum update -y aws-cfn-bootstrap\n",

          "# Install Apache\n",
          "/opt/aws/bin/cfn-init --stack ", { "Ref" : "AWS::StackId" }, " --resource BackendLaunchConfig ",
          "    --region ", { "Ref" : "AWS::Region" }, "\n",

          "# Signal completion\n",
          "/opt/aws/bin/cfn-signal -e $? -r \"Backend setup done\" '", { "Ref" : "BackendWaitHandle" }, "'\n"
        ]]}}
      }
    },

    "BackendSecurityGroup" : {
      "Type" : "AWS::EC2::SecurityGroup",
      "Properties" : {
        "GroupDescription" : "Allow access from private load balancer and bastion as well as outbound HTTP and HTTPS traffic",
        "VpcId" : { "Ref" : "VPC" },
        "SecurityGroupIngress" : [
          { "IpProtocol" : "tcp", "FromPort" : "80", "ToPort" : "80", "SourceSecurityGroupId" : { "Ref" : "PrivateLoadBalancerSecurityGroup" } } ,
          { "IpProtocol" : "tcp", "FromPort" : "22", "ToPort" : "22", "SourceSecurityGroupId" : { "Ref" : "BastionSecurityGroup" } } ],
        "SecurityGroupEgress" : [
           { "IpProtocol" : "tcp", "FromPort" : "80",  "ToPort" : "80",  "CidrIp" : "0.0.0.0/0" } ,
           { "IpProtocol" : "tcp", "FromPort" : "443", "ToPort" : "443", "CidrIp" : "0.0.0.0/0" } ]
      }
    },

    "BackendWaitHandle" : {
      "Type" : "AWS::CloudFormation::WaitConditionHandle"
    },

    "BackendWaitCondition" : {
      "Type" : "AWS::CloudFormation::WaitCondition",
      "DependsOn" : "BackendFleet",
      "Properties" : {
        "Handle"  : { "Ref" : "BackendWaitHandle" },
        "Timeout" : "300",
        "Count"   : { "Ref" : "BackendSize" }
      }
    },
	
    "MyDBSubnetGroup" : {
      "Type" : "AWS::RDS::DBSubnetGroup",
      "Properties" : {
        "DBSubnetGroupDescription" : "Subnets available for the RDS DB Instance",
        "SubnetIds" : [{ "Ref" : "PrivateSubnet" }]
      }
    },


    "myVPCSecurityGroup" : {
        "Type" : "AWS::EC2::SecurityGroup",
        "Properties" :
        {
           "GroupDescription" : "Security group for RDS DB Instance.",
           "VpcId" : { "Ref" : "VPC" }
        }
    },

    "MyDB" : {
      "Type" : "AWS::RDS::DBInstance",
      "Properties" : {
        "DBName" : { "Ref" : "DBName" },
        "AllocatedStorage" : { "Ref" : "DBAllocatedStorage" },
        "DBInstanceClass" : { "Ref" : "DBClass" },
        "Engine" : "MySQL",
        "EngineVersion" : "5.5",
        "MasterUsername" : { "Ref" : "DBUsername" } ,
        "MasterUserPassword" : { "Ref" : "DBPassword" },
        "DBSubnetGroupName" : { "Ref" : "MyDBSubnetGroup" },
        "VPCSecurityGroups" : [ { "Ref" : "myVPCSecurityGroup" }  ]
      }
    },

    "S3BucketForWebsiteContent" : {
      "Type" : "AWS::S3::Bucket",
      "Properties" : {
        "AccessControl" : "PublicRead",
        "WebsiteConfiguration" : {
           "IndexDocument" : "index.html",
           "ErrorDocument" : "error.html"
        }
      }
    },

    "WebsiteCDN" : {
      "Type" : "AWS::CloudFront::Distribution",
      "Properties" : {
         "DistributionConfig" : {
           "Comment" : "CDN for S3-backed website",
           "CustomOrigin" : {
             "DNSName": { "Fn::Join" : ["", [{"Ref" : "S3BucketForWebsiteContent"}, ".s3-website-", {"Ref" : "AWS::Region"}, ".amazonaws.com"]]},
             "HTTPPort" : "80",
             "HTTPSPort" : "443",
             "OriginProtocolPolicy" : "http-only"
           },
           "Enabled" : "true",
           "DefaultRootObject" : "index.html",
           "CNAMEs" : [{ "Fn::Join" : [ "", [{"Ref" : "AWS::StackName"}, ".", {"Ref" : "AWS::Region"}, ".", { "Ref" : "HostedZone" }]]}]
         }
      }
    },

    "WebsiteDNSName" : {
      "Type" : "AWS::Route53::RecordSet",
      "Properties" : {
        "HostedZoneName" : { "Fn::Join" : [ "", [{ "Ref" : "HostedZone" }, "."]]},
        "Comment" : "CNAME redirect custom name to CloudFront distribution",
        "Name" : { "Fn::Join" : [ "", [{"Ref" : "AWS::StackName"}, ".", {"Ref" : "AWS::Region"}, ".", { "Ref" : "HostedZone" }]]},
        "Type" : "CNAME",
        "TTL" : "900",
        "ResourceRecords" : [{ "Fn::Join" : [ "", ["http://", {"Fn::GetAtt" : ["WebsiteCDN", "DomainName"]} ]]}]
      }
    }
  },

  "Outputs" : {
    "WebSite" : {
      "Description" : "URL of the website",
      "Value" :  { "Fn::Join" : [ "", [ "http://", { "Fn::GetAtt" : [ "PublicElasticLoadBalancer", "DNSName" ]}]]}
    },
    "Bastion" : {
      "Description" : "IP Address of the Bastion host",
      "Value" :  { "Ref" : "BastionIPAddress" }
    },
    "WebsiteURL" : {
      "Value" : {"Fn::Join" : [ "", ["http://", {"Ref" : "WebsiteDNSName"} ]] },
      "Description" : "The URL of the newly created website"
    },
    "BucketName" : {
      "Value" : { "Ref" : "S3BucketForWebsiteContent" },
      "Description" : "Name of S3 bucket to hold website content"
    }
  }
}
</textarea>
</div>
<div id="debug-screen" class="debug-screen">
<h2>Debug Information</h2>
<textarea id="output">

</textarea><br/>
<div id="getAJAX">
</div>

</div>

</body>
</html>
